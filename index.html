<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UFO ìš´ì„ í”¼í•˜ê¸°</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: linear-gradient(180deg, #0a0a2e 0%, #16213e 50%, #1a1a2e 100%); display: flex; justify-content: center; align-items: center; min-height: 100vh; font-family: 'Courier New', monospace; overflow: hidden; }
        #gameContainer { position: relative; border: 3px solid #fff; box-shadow: 0 0 20px rgba(255,255,255,0.3); }
        #gameCanvas { display: block; background: linear-gradient(180deg, #000428 0%, #004e92 100%); }
        #ui, #shieldIndicator { position: absolute; color: #fff; font-size: 16px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); z-index: 10; }
        #ui { top: 10px; right: 15px; }
        #shieldIndicator { top: 10px; left: 15px; display: none; color: #00ffff; }
        .shield-active { animation: shield-pulse 0.5s infinite alternate; }
        @keyframes shield-pulse { 0% { opacity: 0.7; } 100% { opacity: 1; } }
        #instructions, #gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 10; }
        #instructions { color: #fff; font-size: 18px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); }
        #gameOver { display: none; color: #ff4444; font-size: 24px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); }
        .blink { animation: blink 1s infinite; }
        @keyframes blink { 0%,50% { opacity:1; } 51%,100% { opacity:0.3; } }
        .star { position: absolute; background: white; border-radius: 50%; animation: twinkle 2s infinite; }
        @keyframes twinkle { 0%,100% { opacity:0.3; } 50% { opacity:1; } }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        <div id="ui"><div>ìƒì¡´ ì‹œê°„: <span id="timer">0</span>ì´ˆ</div></div>
        <div id="shieldIndicator"><div>ğŸ›¡ï¸ ë°©íŒ¨: <span id="shieldTime">0</span>ì´ˆ</div></div>
        <div id="instructions">
            <div>ğŸ›¸ UFO ìš´ì„ í”¼í•˜ê¸° ğŸ›¸</div><br>
            <div>PC: â† â†’ í‚¤ë¡œ ì´ë™</div>
            <div>ìŠ¤í˜ì´ìŠ¤ë°”: ì‹œì‘/ì¬ì‹œì‘</div>
            <div>Z: ë¯¸ì‚¬ì¼ ë°œì‚¬</div><br>
            <div class="blink">ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”!</div>
        </div>
        <div id="gameOver">
            <div>ğŸ’¥ GAME OVER ğŸ’¥</div><br>
            <div>ìƒì¡´ ì‹œê°„: <span id="finalTime">0</span>ì´ˆ</div><br>
            <div class="blink">ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ ì¬ì‹œì‘</div>
        </div>
    </div>

    <script>
        class UFOGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.style.imageRendering = 'pixelated';
                this.gameState = 'waiting';
                this.startTime = 0;
                this.survivedTime = 0;

                this.ufo = { x:300, y:350, width:32, height:16, speed:5 };
                this.meteors = [];
                this.meteorSpawnRate = 0.015;
                this.meteorSpeed = 1.5;
                this.meteorSizeVariation = 0.5;

                this.shields = [];
                this.shieldActive = false;
                this.shieldEndTime = 0;
                this.shieldSpawnRate = 0.003;

                this.missiles = [];
                this.missileSpeed = 5;

                this.sunWarning = false;
                this.sunActive = false;
                this.sunSpeed = 0.5;
                this.sunX = 0;
                this.sunWarningStart = 0;
                this.sunWarningDuration = 3000;
                this.sunThresholdTime = 15; // seconds
                this.sunWidth = this.canvas.width / 3;

                this.keys = {};
                this.touchStartX = 0;
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                this.initControls();
                this.createStars();
                this.gameLoop();
            }

            initControls() {
                document.addEventListener('keydown', e => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space') {
                        e.preventDefault();
                        if (this.gameState === 'waiting' || this.gameState === 'gameOver') this.startGame();
                    }
                    if (e.code === 'KeyZ' && this.gameState === 'playing') {
                        this.missiles.push({ x:this.ufo.x+14, y:this.ufo.y, width:4, height:8, speed:this.missileSpeed });
                    }
                });
                document.addEventListener('keyup', e => { this.keys[e.code] = false; });
                this.canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    this.touchStartX = touch.clientX - rect.left;
                    if (this.gameState === 'waiting' || this.gameState === 'gameOver') this.startGame();
                });
                this.canvas.addEventListener('touchmove', e => {
                    e.preventDefault();
                    if (this.gameState === 'playing') {
                        const touch = e.touches[0];
                        const rect = this.canvas.getBoundingClientRect();
                        const touchX = touch.clientX - rect.left;
                        if (touchX < this.touchStartX - 30) this.ufo.x = Math.max(16, this.ufo.x - this.ufo.speed);
                        else if (touchX > this.touchStartX + 30) this.ufo.x = Math.min(this.canvas.width - 48, this.ufo.x + this.ufo.speed);
                        this.touchStartX = touchX;
                    }
                });
            }

            createStars() { this.stars = Array.from({length:50}, () => ({ x:Math.random()*this.canvas.width, y:Math.random()*this.canvas.height, size:Math.random()*2+1, alpha:Math.random()*0.8+0.2 })); }

            startGame() {
                this.gameState='playing'; this.startTime=Date.now(); this.meteors=[]; this.shields=[]; this.missiles=[];
                this.ufo.x=300; this.meteorSpeed=1.5; this.meteorSpawnRate=0.015; this.meteorSizeVariation=0.5;
                this.shieldActive=false; this.sunWarning=false; this.sunActive=false;
                document.getElementById('instructions').style.display='none';
                document.getElementById('gameOver').style.display='none';
                document.getElementById('shieldIndicator').style.display='none';
            }

            update() {
                if (this.gameState!=='playing') return;
                this.survivedTime = Math.floor((Date.now() - this.startTime)/1000);
                document.getElementById('timer').textContent = this.survivedTime;

                if (this.shieldActive) {
                    const rem = Math.ceil((this.shieldEndTime - Date.now())/1000);
                    if (rem<=0) { this.shieldActive=false; document.getElementById('shieldIndicator').style.display='none'; this.canvas.classList.remove('shield-active'); }
                    else document.getElementById('shieldTime').textContent = rem;
                }

                // Sun attack trigger
                if (!this.sunWarning && !this.sunActive && this.survivedTime >= this.sunThresholdTime) {
                    this.sunWarning = true;
                    this.sunWarningStart = Date.now();
                }
                // Start sun movement
                if (this.sunWarning && Date.now() - this.sunWarningStart > this.sunWarningDuration) {
                    this.sunWarning = false;
                    this.sunActive = true;
                    this.sunX = -this.sunWidth;
                }
                // Move sun
                if (this.sunActive) {
                    this.sunX += this.sunSpeed;
                    if (this.sunX > this.canvas.width) this.sunActive = false;
                }

                // Increase difficulty
                const df = 1 + this.survivedTime*0.15;
                this.meteorSpeed = Math.min(8,1.5*df);
                this.meteorSpawnRate = Math.min(0.08,0.015*df);
                this.meteorSizeVariation = Math.min(1.5,0.5+this.survivedTime*0.02);

                // UFO move
                if (this.keys['ArrowLeft']) this.ufo.x = Math.max(16,this.ufo.x-this.ufo.speed);
                if (this.keys['ArrowRight']) this.ufo.x = Math.min(this.canvas.width-48,this.ufo.x+this.ufo.speed);

                // Spawn meteors only if no sun warning/attack
                if (!this.sunWarning && !this.sunActive && Math.random() < this.meteorSpawnRate) {
                    const sz = 0.5 + Math.random()*this.meteorSizeVariation;
                    const colors=['red','orange','yellow','purple','blue','green'];
                    const col=colors[Math.floor(Math.random()*colors.length)];
                    this.meteors.push({ x:Math.random()*(this.canvas.width-30), y:-30, width:16*sz, height:16*sz, speed:this.meteorSpeed+Math.random()*3, size:sz, color:col });
                }
                // Spawn shields
                if (!this.sunWarning && !this.sunActive && Math.random()<this.shieldSpawnRate && !this.shieldActive) {
                    this.shields.push({ x:Math.random()*(this.canvas.width-20), y:-20, width:20, height:20, speed:2 });
                }

                // Move and filter meteors
                this.meteors = this.meteors.filter(m => { m.y+=m.speed; return m.y < this.canvas.height+50; });
                // Move and collect shields
                this.shields = this.shields.filter(s => { s.y+=s.speed; return s.y < this.canvas.height+30; });
                this.shields = this.shields.filter(s => {
                    if (this.checkCollision(this.ufo,s)) { this.activateShield(); return false; }
                    return true;
                });

                // Meteor-UFO collision
                if (!this.shieldActive && !this.sunActive) {
                    this.meteors.forEach(m => { if (this.checkCollision(this.ufo,m)) this.gameOver(); });
                }

                // Move missiles
                this.missiles.forEach(b => b.y -= b.speed);
                this.missiles = this.missiles.filter(b => b.y + b.height > 0);

                // Missile-meteor collisions
                let survivors=[];
                this.meteors.forEach(m => {
                    let hit=false;
                    this.missiles = this.missiles.filter(b => {
                        if (!hit && this.checkCollision(b,m)) { hit=true; return false; }
                        return true;
                    });
                    if (!hit) survivors.push(m);
                });
                this.meteors = survivors;
            }

            draw() {
                this.ctx.fillStyle='rgba(0,4,40,0.1)';
                this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
                this.stars.forEach(s => { this.ctx.fillStyle=`rgba(255,255,255,${s.alpha})`; this.ctx.fillRect(s.x,s.y,s.size,s.size); });

                if (this.gameState==='playing') {
                    this.drawUFO(this.ufo.x,this.ufo.y);
                    if (this.shieldActive) this.drawShieldEffect(this.ufo.x,this.ufo.y);

                    // Sun warning text
                    if (this.sunWarning) {
                        this.ctx.fillStyle='red'; this.ctx.font='30px Courier New';
                        this.ctx.fillText('âš ï¸ íƒœì–‘ ê³µê²© ê²½ê³ ! âš ï¸',this.canvas.width/2-170,this.canvas.height/2);
                    }
                    // Draw sun
                    if (this.sunActive) {
                        this.ctx.fillStyle='orange';
                        this.ctx.fillRect(this.sunX,0,this.sunWidth,this.canvas.height);
                    }

                    // Draw meteors
                    this.meteors.forEach(m => this.drawMeteor(m.x,m.y,m.size,m.color));
                    // Draw shields
                    this.shields.forEach(s => this.drawShieldItem(s.x,s.y));
                    // Draw missiles
                    this.missiles.forEach(b => { this.ctx.fillStyle='white'; this.ctx.fillRect(b.x,b.y,b.width,b.height); });
                }
            }

            drawUFO(x,y) { /* existing drawing code... */ }
            drawMeteor(x,y,size,color) { /* existing drawing code... */ }
            drawShieldItem(x,y) { /* existing drawing code... */ }
            drawShieldEffect(x,y) { /* existing drawing code... */ }
            checkCollision(r1,r2) { return r1.x<r2.x+r2.width && r1.x+r1.width>r2.x && r1.y<r2.y+r2.height && r1.y+r1.height>r2.y; }

            activateShield() { this.shieldActive=true; this.shieldEndTime=Date.now()+5000; document.getElementById('shieldIndicator').style.display='block'; this.canvas.classList.add('shield-active'); }
            gameOver() { this.gameState='gameOver'; document.getElementById('finalTime').textContent=this.survivedTime; document.getElementById('gameOver').style.display='block'; }

            gameLoop() { this.update(); this.draw(); requestAnimationFrame(() => this.gameLoop()); }
        }
        window.addEventListener('load', () => { new UFOGame(); });
    </script>
</body>
</html>
